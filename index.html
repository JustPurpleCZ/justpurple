<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adam Zahor</title>
    <link rel="icon" type="image/x-icon" href="tri.jpg">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0066ff;
            font-family: monospace;
            position: relative;
            min-height: 200vh; /* Make the page scrollable */
            overflow-x: hidden;
        }
/* Basic Party Mode Styles */
body.party-mode {
    overflow: hidden; /* Lock scrolling */
}

/* Party Mode Disc */
.circular-image.party-mode {
    position: fixed;
    width: 150vh;
    height: 150vh;
    left: -120vh; /* Only show right quarter */

    transform: translateY(-50%);
    margin: 0;
    z-index: 4;
    transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* Content box exit animation */
.content-box.party-mode {
    transform: translateX(250%) !important; /* Force move offscreen */
    transition: transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* Rhomboid animations for party mode */
.rhomboid.party-mode-hide {
    transform: translateX(400px) !important;
    transition: transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* Close button (cross) rhomboid */
.rhomboid-close {
    position: absolute;
    width: 200px;
    height: 120px;
    background-color: rgba(255, 255, 255, 0.15);
    clip-path: polygon(25% 0%, 100% 0%, 75% 100%, 0% 100%);
    transform: translateX(400px);
    transition: transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
    right: 0;
    top: 5%;
    pointer-events: all;
    cursor: pointer;
    z-index: 100;
}

.rhomboid-close.active {
    transform: translateX(0);
    animation: rhomboid-wave 5s ease-in-out infinite;
}
.card.party-mode .card-back {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
}
.card.party-mode .card-back h3 {
    font-size: 1.1em;
    margin-top: 0;
}

.card.party-mode .card-back img {
    max-width: 90%;
    max-height: 70%;
    border-radius: 8px;
    object-fit: cover;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}
/* Party cards styles */


@media screen and (max-width: 992px) {
    .card.party-mode {
        width: 150px !important;
        height: 200px !important;
    }
}

@media screen and (max-width: 600px) {
    .card.party-mode {
        width: 120px !important;
        height: 170px !important;
    }
}
.cards-container {
    position: fixed;
    bottom: 40px;
    left: 0;
    width: 100%;
    height: 260px; /* Enough height for cards + hover effect */
    z-index: 10;
    opacity: 0;
    transition: opacity 0.2s ease;
    pointer-events: none;
}

.cards-container.visible {
    opacity: 1;
    pointer-events: all;
}

/* Card styles */
.card {
    transform: translateY(300px);
    position: absolute;
    width: 180px;
    height: 240px;
    bottom: 0;
    perspective: 1000px;
    cursor: pointer;
    z-index: 1;
    border-radius: 15px;
    overflow: hidden;
    transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1),
                left 0.5s cubic-bezier(0.34, 1.56, 0.64, 1),
                width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1),
                height 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
}
.card.scrolled {
    transform: translateY(0);
}

.card:hover {
    transform: translateY(-20px);
}

/* Active card styles */
.card.active {
    position: fixed;
    width: 500px;
    height: 400px;
    z-index: 20;
    transition: transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1),
                width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1),
                height 0.8s cubic-bezier(0.34, 1.56, 0.64, 1),
                top 0.8s cubic-bezier(0.34, 1.56, 0.64, 1),
                left 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.card.active:hover {
    transform: none;
}

/* Card inner container for flip effect */
.card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.8s;
    transform-style: preserve-3d;
    border-radius: 15px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    will-change: transform;
}

.card.active .card-inner {
    transform: rotateY(180deg);
}

/* Card front and back */
.card-front, .card-back {
    position: absolute;
    width: calc(100% - 4px);
    height: calc(100% - 4px);
    backface-visibility: hidden;
    border-radius: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(102, 51, 204, 1);
    border: 2px solid rgba(255, 255, 255, 0.4);
    padding: 0px;
    color: white;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
}

.card-back {
    transform: rotateY(180deg);
    text-align: center;
}

/* Card logo */
.card-logo {
    width: 60px;
    height: 60px;
    margin-top: 20px;
    background-color: rgba(153, 0, 255, 1);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 15px rgba(153, 0, 255, 0.7);
}

.card-logo svg {
    width: 36px;
    height: 36px;
}

/* Glint effect */
.card::after {
    content: '';
    position: absolute;
    top: -220%;
    left: 35%;
    width: 30%;
    height: 230%;
    rotate: 45deg;
    border-radius: 15px;
    background: rgba(255,255,255,0.4);
    opacity: 1;
    z-index: 2;
    pointer-events: none;
}

.card:hover::after {
    animation: glint 0.8s;
}
@keyframes glint {
    0%{
        top: -200%;
    }
    98%{
        top: 200%;
        opacity: 1;
    }
    99%{
        opacity: 0;
    }
    100%{
        top: -200%;
    }
}

/* Processing state - prevent multiple clicks */
.card.processing {
    pointer-events: none;
}

/* Responsive adjustments */
@media screen and (max-width: 992px) {
    .card {
        width: 150px;
        height: 200px;
    }
    
    .card.active {
        width: 90%;
        max-width: 400px;
        height: 350px;
    }
}

@media screen and (max-width: 600px) {
    .card {
        width: 120px;
        height: 170px;
    }
    
    .card-logo {
        width: 40px;
        height: 40px;
    }
    
    .card-logo svg {
        width: 24px;
        height: 24px;
    }
}
        .gradient-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            background: linear-gradient(-45deg, #0066ff, #9900ff, #7700cc, #9900ff);
            background-size: 400% 400%;
            transition: opacity 1.5s ease-out;
            z-index: 1;
        }
        
        .gradient-overlay.active {
            opacity: 0.8;
            animation: gradient 15s ease infinite;
        }
        
        @keyframes gradient {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
        
        /* Container for the name animation */
        #animation-container {
            display: flex;
            flex-wrap: nowrap; /* Prevent wrapping to keep name on one line */
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            white-space: nowrap; /* Ensure text stays on one line */
        }
        
        /* Scrolled state for the animation container */
        #animation-container.scrolled {
            top: 40px;
            left: 80px;
            transform: translate(0, 0) scale(0.4);
            justify-content: flex-start;
        }
        
        #tagline-container {
            margin-top: 60px;
            font-size: 24px;
            color: white;
            font-family: monospace;
            letter-spacing: 2px;
            text-align: right;
            width: 90vw;
            max-width: 600px;
            min-height: 30px;
            opacity: 1 ;
            transition: opacity 0.5s ease, transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 100px);
            z-index: 10;
        }
        
        #tagline-container.scrolled {
            opacity: 0;
            transform: translate(-50%, 50px) scale(0.6);
        }
        
        /* New content containers that slide in when scrolling */
        .content-container {
            position: fixed;
            width: 90vw;
            height: 80vh;
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding: 10vh;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.6s ease-in-out;
        }
        
        .content-container.visible {
            opacity: 1;
            pointer-events: all;
        }
        
        .circular-image {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            margin-bottom: -100vh;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            animation: none;
            position: relative;
            overflow: hidden;
        }
        
        .circular-image.scrolled {
            margin: 0;
            animation: spin 20s linear infinite;
        }
        .circular-image img{
            height: 100%;
            width: auto;
            
        }
        
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        
        .content-box {
            width: 500px;
            max-width: 50vw;
            height: 30vh;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 30px;
            backdrop-filter: blur(10px);
            transform: translateY(100vh);
            transition: transform 1s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.2);
            color: white;
            overflow: auto;
        }
        
        .content-box.scrolled {
            transform: translateY(0);
        }
        
        .content-box h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
            font-weight: normal;
            letter-spacing: 2px;
        }
        
        .content-box p {
            font-size: 1em;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        /* Keep all existing bubble and rhomboid styles */
        #bubbles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 3;
        }
        
        .bubble-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 0.15s ease-out;
        }
        
        #bubble-layer-front {
            z-index: 5;
        }
        
        #bubble-layer-middle {
            z-index: 4;
        }
        
        #bubble-layer-back {
            z-index: 3;
        }
        
        .bubble {
            position: fixed;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            transform: translate(0, 0);
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        #bubble-layer-back .bubble {
            background-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
        }
        
        #bubble-layer-middle .bubble {
            background-color: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.25);
        }
        
        #bubble-layer-front .bubble {
            background-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.3);
        }
        
        .bubble.move-in {
            transition: transform 2.5s ease-out, opacity 0.5s ease;
        }
        
        .bubble.float {
            animation: float 8s ease-in-out infinite;
        }
        
        @keyframes float {
            0% {
                transform: translate(var(--float-x), var(--float-y));
            }
            33% {
                transform: translate(calc(var(--float-x) + 15px), calc(var(--float-y) + 15px));
            }
            66% {
                transform: translate(calc(var(--float-x) - 15px), calc(var(--float-y) - 10px));
            }
            100% {
                transform: translate(var(--float-x), var(--float-y));
            }
        }
        
        /* Rhomboids menu (keep fixed in place) */
        #rhomboids-container {
            position: fixed;
            right: 0;
            top: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 90;
        }
        
        .rhomboid {
            position: absolute;
            width: 200px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.15);
            clip-path: polygon(25% 0%, 100% 0%, 75% 100%, 0% 100%);
            transform: translateX(400px);
            transition: transform 1.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            right: 0;
            pointer-events: all;
            cursor: pointer;
        }
        
        .rhomboid.active {
            animation: rhomboid-wave 5s ease-in-out infinite;
            transition: 0.3s ease;
        }
        .rhomboid.active:hover {
            right: 2vw;
        }

        @keyframes rhomboid-wave {
            0% {
                transform: translateX(0);
            }
            50% {
                transform: translateX(-20px);
            }
            100% {
                transform: translateX(0);
            }
        }
        
        /* SVG icon styling */
        .svg-icon-container {
            position: absolute;
            width: 120px;
            height: 120px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .svg-icon {
            width: 100%;
            height: 100%;
        }

        .svg-path {
            fill: none;
            stroke: white;
            stroke-width: 0.5;
            stroke-linecap: circle;
            stroke-linejoin: circle;
            stroke-dasharray: 0;
            stroke-dashoffset: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        /* Keep all the letter and triangle styles from the original code */
        .letter {
            display: grid;
            grid-template-rows: repeat(3, 1fr);
            grid-template-columns: repeat(2, 1fr);
            margin: 0.5vw;
        }
        
        .cell {
            position: relative;
            aspect-ratio: 1/1;
            width: calc(2vw + 15.5px);
            height: calc(2vw + 15.5px);
        }
        
        .triangle {
            position: absolute;
            width: 0;
            height: 0;
            opacity: 0;
            transform-origin: center;
            transition: opacity 0.2s ease;
        }
        
        .triangle-top-left {
            border-left: calc(2vw + 16px) solid white;
            border-bottom: calc(2vw + 16px) solid transparent;
            transform-origin: 50% 50%;
        }
        
        .triangle-top-right {
            border-top: calc(2vw + 16px) solid white;
            border-left: calc(2vw + 16px) solid transparent;
            transform-origin: 50% 50%;
        }
        
        .triangle-bottom-left {
            border-bottom: calc(2vw + 16px) solid white;
            border-right: calc(2vw + 16px) solid transparent;
            transform-origin: 50% 50%;
        }
        
        .triangle-bottom-right {
            border-right: calc(2vw + 16px) solid white;
            border-top: calc(2vw + 16px) solid transparent;
            transform-origin: 50% 50%;
        }
        
        .visible {
            opacity: 1;
            animation: none;
        }
        
        .rotate-0 { transform: rotate(0deg); opacity: 1; }
        .rotate-90 { transform: rotate(90deg); opacity: 1; }
        .rotate-180 { transform: rotate(180deg); opacity: 1; }
        .rotate-270 { transform: rotate(270deg); opacity: 1; }
        .rotate-360 { transform: rotate(0deg); opacity: 1; }
        
        .char-slot {
            display: inline-block;
            width: 1em;
            text-align: center;
        }
        
        /* Scroll progress indicator */
        .scroll-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: monospace;
            letter-spacing: 2px;
            text-align: center;
            opacity: 0.8;
            z-index: 20;
            transition: opacity 0.5s ease;
        }
        
        .scroll-icon {
            width: 30px;
            height: 50px;
            border: 2px solid white;
            border-radius: 15px;
            margin: 0 auto 5px;
            position: relative;
        }
        
        .scroll-icon::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            transform: translateX(-50%);
            animation: scrollDown 2s infinite;
        }
        
        @keyframes scrollDown {
            0% {
                transform: translate(-50%, 0);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, 20px);
                opacity: 0;
            }
        }

        /* Responsive styles */
        @media screen and (max-width: 768px) {
            .circular-image {
                width: 200px;
                height: 200px;
                margin-right: 15px;
            }
            
            .content-box {
                width: 60vw;
                height: 350px;
                padding: 20px;
            }
            
            #animation-container.scrolled {
                top: 20px;
                left: 40px;
                transform: translate(0, 0) scale(0.3);
            }
            
            /* Force name to stay on one line */
            #animation-container {
                flex-wrap: nowrap;
                white-space: nowrap;
                width: auto;
            }
            
            .cell {
                width: calc(3vw + 10px);
                height: calc(3vw + 10px);
            }
            
            .triangle-top-left {
                border-left: calc(3vw + 11px) solid white;
                border-bottom: calc(3vw + 11px) solid transparent;
            }
            
            .triangle-top-right {
                border-top: calc(3vw + 11px) solid white;
                border-left: calc(3vw + 11px) solid transparent;
            }
            
            .triangle-bottom-left {
                border-bottom: calc(3vw + 11px) solid white;
                border-right: calc(3vw + 11px) solid transparent;
            }
            
            .triangle-bottom-right {
                border-right: calc(3vw + 11px) solid white;
                border-top: calc(3vw + 11px) solid transparent;
            }
        }
        
        @media screen and (max-width: 480px) {
            .content-container {
                flex-direction: column;
                padding-top: 120px;
            }
            
            .circular-image {
                width: 150px;
                height: 150px;
                margin-right: 0;
                margin-bottom: 20px;
            }
            
            .content-box {
                width: 90vw;
                max-width: 90vw;
                height: 300px;
            }
            
            #animation-container.scrolled {
                top: 15px;
                left: 30px;
                transform: translate(0, 0) scale(0.25);
            }
            
            .cell {
                width: calc(4vw + 6px);
                height: calc(4vw + 6px);
            }
            
            .triangle-top-left {
                border-left: calc(4vw + 6px) solid white;
                border-bottom: calc(4vw + 6px) solid transparent;
            }
            
            .triangle-top-right {
                border-top: calc(4vw + 6px) solid white;
                border-left: calc(4vw + 6px) solid transparent;
            }
            
            .triangle-bottom-left {
                border-bottom: calc(4vw + 6px) solid white;
                border-right: calc(4vw + 6px) solid transparent;
            }
            
            .triangle-bottom-right {
                border-right: calc(4vw + 6px) solid white;
                border-top: calc(4vw + 6px) solid transparent;
            }
        }
    </style>
</head>
<body>
    <div class="gradient-overlay"></div>
    
    <!-- Main animation container for the name -->
    <div id="animation-container"></div>
    <div id="tagline-container"></div>
    
    <!-- New content that will appear on scroll -->
    <div class="content-container">
        <div class="circular-image"><img src="ellen.png" alt=""></div>
        <div class="content-box">
            <h2>About Me</h2>
            <p>Hello! I'm Adam Zahor, and I make things, sometimes</p>
        </div>
    </div>
    <!-- Add this right after your existing content-container div -->
<div class="cards-container">
    <div class="card" data-card-id="1">
        <div class="card-inner">
            <div class="card-front">
                <div class="card-logo">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="10" stroke="white" stroke-width="1.5"/>
                        <path d="M8 12L11 15L16 9" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
            </div>
            <div class="card-back">
                <h3>Card 1</h3>
                <p>This is the content for card 1. It will be revealed when the card is active.</p>
            </div>
        </div>
    </div>
    
    <div class="card" data-card-id="2">
        <div class="card-inner">
            <div class="card-front">
                <div class="card-logo">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="4" y="4" width="16" height="16" rx="2" stroke="white" stroke-width="1.5"/>
                        <path d="M12 8V16" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
                        <path d="M8 12H16" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </div>
            </div>
            <div class="card-back">
                <h3>Card 2</h3>
                <p>This is the content for card 2. It will be revealed when the card is active.</p>
            </div>
        </div>
    </div>
    
    <div class="card" data-card-id="3">
        <div class="card-inner">
            <div class="card-front">
                <div class="card-logo">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 3L19 10H15V21H9V10H5L12 3Z" stroke="white" stroke-width="1.5" stroke-linejoin="round"/>
                    </svg>
                </div>
            </div>
            <div class="card-back">
                <h3>Card 3</h3>
                <p>This is the content for card 3. It will be revealed when the card is active.</p>
            </div>
        </div>
    </div>
    
    <div class="card" data-card-id="4">
        <div class="card-inner">
            <div class="card-front">
                <div class="card-logo">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="7" r="4" stroke="white" stroke-width="1.5"/>
                        <path d="M5 21V19C5 16.2386 7.23858 14 10 14H14C16.7614 14 19 16.2386 19 19V21" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </div>
            </div>
            <div class="card-back">
                <h3>Card 4</h3>
                <p>This is the content for card 4. It will be revealed when the card is active.</p>
            </div>
        </div>
    </div>
    
    <div class="card" data-card-id="5">
        <div class="card-inner">
            <div class="card-front">
                <div class="card-logo">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12Z" stroke="white" stroke-width="1.5"/>
                        <path d="M12 7V12L16 14" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
            </div>
            <div class="card-back">
                <h3>Card 5</h3>
                <p>This is the content for card 5. It will be revealed when the card is active.</p>
            </div>
        </div>
    </div>
</div>
    <!-- Bubbles container -->
    <div id="bubbles-container">
        <div id="bubble-layer-back" class="bubble-layer"></div>
        <div id="bubble-layer-middle" class="bubble-layer"></div>
        <div id="bubble-layer-front" class="bubble-layer"></div>
    </div>
    
    <!-- Rhomboids menu -->
    <div id="rhomboids-container">
        <!-- Home icon -->
        <div class="rhomboid" style="top: 5%;">
            <div class="svg-icon-container">
                <svg class="svg-icon" viewBox="2 0 20 18" xmlns="http://www.w3.org/2000/svg">
                    <path class="svg-path" id="home-outline-0" 
                          d="M12,4 L17,9 L16,9 L16,13 L12,13 L8,13 L8,9 L7,9 L12,4">
                    </path>
                </svg>
            </div>
        </div>
        
        <!-- Projects icon -->
        <div class="rhomboid" style="top: 15%;">
            <div class="svg-icon-container">
                <svg class="svg-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path class="svg-path" id="left-rectangle" 
                        d="M9,8 L6,8 L6,18 L10,18 L10,16 L9,16 L9,8">
                    </path>
                    <path class="svg-path" id="middle-rectangle" 
                        d="M9,6 L15,6 L15,16 L9,16 Z">
                    </path>
                    <path class="svg-path" id="right-rectangle" 
                        d="M15,8 L18,8 L18,18 L14,18 L14,16 L15,16 L15,8">
                    </path>
                </svg>
            </div>
        </div>
        
        <!-- Portfolio icon -->
        <div class="rhomboid" style="top: 25%;">
            <div class="svg-icon-container">
                <svg class="svg-icon" viewBox="2 0 20 20" xmlns="http://www.w3.org/2000/svg">
                    <path class="svg-path" id="cube-outline" 
                        d="M12,4.5 L16.5,7.5 L16.5,13.5 L12,16.5 L7.5,13.5 L7.5,7.5 Z M7.5,7.5 L12,10.5 M16.5,7.5 L12,10.5 M12,10.5 L12,16.5">
                    </path>
                </svg>
            </div>
        </div>
        
        <!-- Contact icon -->
        <div class="rhomboid" style="top: 35%;">
            <div class="svg-icon-container">
                <svg class="svg-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path class="svg-path" id="mail-outline" 
                        d="M5,7 L19,7 L19,17 L5,17 Z M5,7 L12,12 L19,7">
                    </path>
                </svg>
            </div>
        </div>
        <div class="rhomboid-close">
            <div class="svg-icon-container">
                <svg class="svg-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path class="svg-path" id="cross-1" 
                          d="M6,6 L18,18">
                    </path>
                    <path class="svg-path" id="cross-2" 
                          d="M18,6 L6,18">
                    </path>
                </svg>
            </div>
        </div>
    </div>
    
    
    <!-- Scroll indicator -->
    <div class="scroll-indicator">
        <div class="scroll-icon"></div>
        <span>SCROLL</span>
    </div>

    <script>
        const name = "ADAM ZAHOR";
        
        // Letter definitions using triangle types (0: none, 1: top-left, 2: top-right, 3: bottom-left, 4: bottom-right)
        const letterDefinitions = {
            'A': [4, 3, 1, 2, 1, 2],
            'B': [1, 3, 1, 3, 3, 1],
            'C': [1, 2, 1, 0, 3, 4],
            'D': [0, 0, 2, 2, 4, 4],
            'E': [1, 2, 1, 0, 3, 0],
            'F': [1, 2, 1, 0, 0, 0],
            'G': [1, 2, 1, 0, 3, 2],
            'H': [3, 4, 3, 4, 1, 2],
            'I': [1, 0, 3, 0, 1, 0],
            'J': [0, 2, 0, 0, 3, 4],
            'K': [1, 4, 3, 1, 1, 3],
            'L': [1, 0, 0, 0, 3, 4],
            'M': [3, 4, 2, 1, 3, 4],
            'N': [1, 0, 2, 1, 0, 1],
            'O': [4, 3, 1, 4, 2, 1],
            'P': [1, 2, 1, 2, 0, 0],
            'Q': [1, 2, 1, 0, 3, 2],
            'R': [1, 3, 3, 1, 1, 3],
            'S': [4, 3, 2, 3, 2, 1],
            'T': [1, 1, 0, 0, 0, 0],
            'U': [1, 0, 1, 0, 3, 4],
            'V': [1, 0, 1, 0, 0, 4],
            'W': [1, 0, 1, 1, 0, 1],
            'X': [1, 2, 3, 4, 0, 0],
            'Y': [1, 2, 0, 0, 0, 0],
            'Z': [1, 1, 4, 1, 4, 4]
        };
        
        // Triangle classes mapping
        const triangleClasses = [
            "",
            "triangle-top-left",
            "triangle-top-right",
            "triangle-bottom-left",
            "triangle-bottom-right"
        ];
        
        // Variables for parallax effect
        let mouseX = 0;
        let mouseY = 0;
        let centerX = window.innerWidth / 2;
        let centerY = window.innerHeight / 2;
        let parallaxEnabled = false;
        let animationComplete = false;
        
        // Create the letters
        const animationContainer = document.getElementById('animation-container');
        
        // Create a wrapper div to ensure all letters stay together
        const nameWrapper = document.createElement('div');
        nameWrapper.style.display = 'flex';
        nameWrapper.style.flexWrap = 'nowrap';
        nameWrapper.style.whiteSpace = 'nowrap';
        animationContainer.appendChild(nameWrapper);
        
        name.split('').forEach(char => {
            if (char === ' ') {
                const spaceDiv = document.createElement('div');
                spaceDiv.style.width = 'calc(2vw + 15px)';
                spaceDiv.classList.add('space');
                nameWrapper.appendChild(spaceDiv);
                return;
            }
            
            const letterDef = letterDefinitions[char.toUpperCase()];
            if (!letterDef) return;
            
            const letterDiv = document.createElement('div');
            letterDiv.className = 'letter';
            
            for (let i = 0; i < 6; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                
                if (letterDef[i] > 0) {
                    const triangle = document.createElement('div');
                    triangle.className = `triangle ${triangleClasses[letterDef[i]]}`;
                    triangle.dataset.index = i;
                    cell.appendChild(triangle);
                }
                
                letterDiv.appendChild(cell);
            }
            
            nameWrapper.appendChild(letterDiv);
        });
        
        // Adjust space width based on screen size
        function adjustSpaceWidth() {
            const spaces = document.querySelectorAll('.space');
            let width = 'calc(2vw + 15px)';
            
            if (window.innerWidth <= 768) {
                width = 'calc(3vw + 10px)';
            }
            
            if (window.innerWidth <= 480) {
                width = 'calc(4vw + 5px)';
            }
            
            spaces.forEach(space => {
                space.style.width = width;
            });
            
            // Update center coordinates when window is resized
            centerX = window.innerWidth / 2;
            centerY = window.innerHeight / 2;
        }
        
        // Function to update parallax effect based on mouse position
        function updateParallax(e) {
            if (!parallaxEnabled) return;
            
            // Calculate mouse position relative to center (normalized from -1 to 1)
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            const normalizedX = (mouseX - centerX) / centerX; // -1 to 1
            const normalizedY = (mouseY - centerY) / centerY; // -1 to 1
            
            // Apply different movement speeds to each layer
            const frontLayer = document.getElementById('bubble-layer-front');
            const middleLayer = document.getElementById('bubble-layer-middle');
            const backLayer = document.getElementById('bubble-layer-back');
            
            // More movement for front layer
            frontLayer.style.transform = `translate(${-normalizedX * 40}px, ${-normalizedY * 40}px)`;
            
            // Medium movement for middle layer
            middleLayer.style.transform = `translate(${-normalizedX * 20}px, ${-normalizedY * 20}px)`;
            
            // Subtle movement for back layer
            backLayer.style.transform = `translate(${-normalizedX * 10}px, ${-normalizedY * 10}px)`;
        }
        
        // Add mouse move event listener for parallax
        document.addEventListener('mousemove', updateParallax);
        
        // Handle touch movement for mobile
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            updateParallax({
                clientX: e.touches[0].clientX,
                clientY: e.touches[0].clientY
            });
        }, { passive: false });
        
        // Animation function
        function animateLetters() {
            const letters = document.querySelectorAll('.letter');
            let allTriangles = [];
            
            // For each row
            for (let row = 0; row < 3; row++) {
                // Go through each letter, collecting left then right triangles
                for (let letterIndex = 0; letterIndex < letters.length; letterIndex++) {
                    // First get the left triangle (col=0)
                    const leftCellIndex = row * 2 + 0;
                    const leftTriangle = letters[letterIndex].querySelector(`.triangle[data-index="${leftCellIndex}"]`);
                    if (leftTriangle) allTriangles.push(leftTriangle);
                    
                    // Then get the right triangle (col=1)
                    const rightCellIndex = row * 2 + 1;
                    const rightTriangle = letters[letterIndex].querySelector(`.triangle[data-index="${rightCellIndex}"]`);
                    if (rightTriangle) allTriangles.push(rightTriangle);
                }
            }
            
            // Process triangles
            const rotationSteps = ['rotate-0', 'rotate-90', 'rotate-180', 'rotate-270', 'rotate-0', 'rotate-90', 'rotate-180', 'rotate-270', 'rotate-360'];
            
            // Get total animation time to know when to start the tagline
            const lastTriangleVisibleTime = (allTriangles.length - 1) * 30; // Time until last triangle appears
            
            // Start all triangles with a staggered delay
            allTriangles.forEach((triangle, index) => {
                setTimeout(() => {
                    // Make triangle visible immediately
                    triangle.classList.add('visible');
                    
                    // Rotate through all positions
                    let rotationIndex = 0;
                    
                    function rotateTriangle() {
                        // Clear previous rotation classes
                        triangle.classList.remove('rotate-0', 'rotate-90', 'rotate-180', 'rotate-270', 'rotate-360');
                        
                        // Apply current rotation
                        triangle.classList.add(rotationSteps[rotationIndex]);
                        
                        rotationIndex++;
                        
                        if (rotationIndex < rotationSteps.length) {
                            // Continue to next rotation after delay
                            setTimeout(rotateTriangle, 200);
                        }
                    }
                    
                    // Start rotation sequence
                    rotateTriangle();
                    
                }, index * 30); // Staggered delay between triangles
            });
            
            // After last triangle is visible, start the tagline animation with a small delay
            setTimeout(animateTagline, lastTriangleVisibleTime + 200);
        }
        
        // Tagline animation function
        function animateTagline() {
            const tagline = "Just_PurpleCZ";
            const taglineContainer = document.getElementById('tagline-container');
            
            // Create character slots
            for (let i = 0; i < tagline.length; i++) {
                const charSlot = document.createElement('span');
                charSlot.className = 'char-slot';
                charSlot.textContent = ' ';
                charSlot.dataset.finalChar = tagline[i];
                taglineContainer.appendChild(charSlot);
            }
            
            const charSlots = document.querySelectorAll('.char-slot');
            
            // Random character set
            const randomChars = '!@#$%^&*()_+-=[]{}|;:,./<>?`~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            
            // Calculate when tagline animation will finish
            const taglineFinishTime = (tagline.length - 1) * 100 + (12 * 50);
            
            // Animate each character slot with random characters
            charSlots.forEach((slot, index) => {
                setTimeout(() => {
                    let iterations = 0;
                    const finalChar = slot.dataset.finalChar;
                    const interval = setInterval(() => {
                        // Show random character
                        if (iterations < 12) {
                            slot.textContent = randomChars[Math.floor(Math.random() * randomChars.length)];
                        } else {
                            // Show final character
                            slot.textContent = finalChar;
                            clearInterval(interval);
                            
                            // If this is the last character, animate the background and rhomboids
                            if (index === charSlots.length - 1) {
                                setTimeout(finalAnimation, 300);
                            }
                        }
                        iterations++;
                    }, 50); // 50ms per character change
                    
                }, index * 100); // 100ms delay between characters
            });
        }
        
        // Function to create bubbles
        function createBubbles() {
            // Clear existing bubbles
            document.getElementById('bubble-layer-back').innerHTML = '';
            document.getElementById('bubble-layer-middle').innerHTML = '';
            document.getElementById('bubble-layer-front').innerHTML = '';
            
            // Create bubbles in each layer
            createLayerBubbles('bubble-layer-back', 20);
            createLayerBubbles('bubble-layer-middle', 15);
            createLayerBubbles('bubble-layer-front', 15);
            
            // Enable parallax effect once bubbles are created
            setTimeout(() => {
                parallaxEnabled = true;
            }, 2500);
        }
        
        // Function to animate any SVG path
        function animatePath(pathId, duration = 1500, delay = 0) {
            setTimeout(() => {
                const pathElement = document.getElementById(pathId);
                if (!pathElement) return;
                
                // Make the path visible
                pathElement.style.opacity = '1';
                
                // Get the total length of the path
                const pathLength = pathElement.getTotalLength();
                
                // Setup the initial state - dashed line with full length as the gap
                pathElement.style.strokeDasharray = pathLength;
                pathElement.style.strokeDashoffset = pathLength;
                
                // Animate the drawing of the path
                let startTime = null;
                
                function drawPath(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const elapsed = timestamp - startTime;
                    
                    if (elapsed < duration) {
                        const progress = elapsed / duration;
                        const drawLength = pathLength * progress;
                        pathElement.style.strokeDashoffset = pathLength - drawLength;
                        requestAnimationFrame(drawPath);
                    } else {
                        // Ensure path is fully drawn
                        pathElement.style.strokeDashoffset = 0;
                    }
                }
                
                requestAnimationFrame(drawPath);
            }, delay);
        }
        
        // Function to animate a group of paths in sequence
        function animatePathGroup(pathIds, durationPerPath = 800, delayBetweenPaths = 0, initialDelay = 0) {
            pathIds.forEach((pathId, index) => {
                const delay = initialDelay + (index * (durationPerPath + delayBetweenPaths));
                animatePath(pathId, durationPerPath, delay);
            });
        }
        
        // Function to create bubbles for a specific layer
        function createLayerBubbles(layerId, count) {
            const layerEl = document.getElementById(layerId);
            
            // Size ranges vary by layer to enhance depth perception
            let maxSize, minSize, moveDistance;
            
            if (layerId === 'bubble-layer-front') {
                // Largest bubbles in front
                maxSize = window.innerWidth <= 480 ? 40 : 
                          window.innerWidth <= 768 ? 60 : 160;
                minSize = window.innerWidth <= 480 ? 20 : 
                          window.innerWidth <= 768 ? 30 : 40;
                moveDistance = window.innerWidth <= 480 ? 15 : 
                               window.innerWidth <= 768 ? 25 : 200;
            } else if (layerId === 'bubble-layer-middle') {
                // Medium bubbles in middle
                maxSize = window.innerWidth <= 480 ? 30 : 
                          window.innerWidth <= 768 ? 45 : 120;
                minSize = window.innerWidth <= 480 ? 10 : 
                          window.innerWidth <= 768 ? 15 : 30;
                moveDistance = window.innerWidth <= 480 ? 10 : 
                               window.innerWidth <= 768 ? 20 : 150;
            } else {
                // Smallest bubbles in back
                maxSize = window.innerWidth <= 480 ? 20 : 
                          window.innerWidth <= 768 ? 30 : 80;
                minSize = window.innerWidth <= 480 ? 3 : 
                          window.innerWidth <= 768 ? 5 : 10;
                moveDistance = window.innerWidth <= 480 ? 5 : 
                               window.innerWidth <= 768 ? 15 : 100;
            }
            
            const sizeRange = maxSize - minSize;
            
            for (let i = 0; i < count; i++) {
                const bubble = document.createElement('div');
                bubble.className = 'bubble';
                
                // Random size with responsive adjustment
                const size = Math.floor(Math.random() * sizeRange) + minSize;
                bubble.style.width = `${size}px`;
                bubble.style.height = `${size}px`;
                
                // Determine which side the bubble will come from (0=top, 1=right, 2=bottom, 3=left)
                const side = i % 4;
                
                // Starting positions outside the viewport
                if (side === 0) { // Top
                    bubble.style.top = `-${size}px`;
                    bubble.style.left = `${Math.random() * 100}%`;
                } else if (side === 1) { // Right
                    bubble.style.top = `${Math.random() * 100}%`;
                    bubble.style.right = `-${size}px`;
                } else if (side === 2) { // Bottom
                    bubble.style.bottom = `-${size}px`;
                    bubble.style.left = `${Math.random() * 100}%`;
                } else { // Left
                    bubble.style.top = `${Math.random() * 100}%`;
                    bubble.style.left = `-${size}px`;
                }
                
                // Add to container
                layerEl.appendChild(bubble);
                
                // Make bubble visible initially
                setTimeout(() => {
                    bubble.style.opacity = '1';
                }, 100);
                
                // Calculate final position for the bubble to float to
                const finalX = (side === 1) ? `-${Math.random() * moveDistance + 10}px` : // Right side
                               (side === 3) ? `${Math.random() * moveDistance + 10}px` : '0px'; // Left side
                               
                const finalY = (side === 0) ? `${Math.random() * moveDistance + 10}px` : // Top
                               (side === 2) ? `-${Math.random() * moveDistance + 10}px` : '0px'; // Bottom
                
                // Store the final position for the floating animation
                bubble.style.setProperty('--float-x', finalX);
                bubble.style.setProperty('--float-y', finalY);
                
                // Add move-in class with a delay
                setTimeout(() => {
                    bubble.classList.add('move-in');
                    bubble.style.transform = `translate(${finalX}, ${finalY})`;
                    
                    // After moving in, start floating
                    setTimeout(() => {
                        bubble.classList.remove('move-in');
                        bubble.classList.add('float');
                    }, 2500); // Wait for move-in transition to complete
                }, 200 + (i * 50)); // Staggered start
            }
        }
        
        // Final animation with gradient background and rhomboids
        function finalAnimation() {
            // Get the gradient overlay and activate it
            const gradientOverlay = document.querySelector('.gradient-overlay');
            gradientOverlay.classList.add('active');
            
            // Create and animate bubbles
            createBubbles();
            
            // Animate rhomboids in a wave-like motion
            const rhomboids = document.querySelectorAll('.rhomboid');
            rhomboids.forEach((rhomboid, index) => {
                setTimeout(() => {
                    // First move rhomboid into view
                    rhomboid.style.transform = 'translateX(0)';
                    
                    // Animate first rhomboid (home icon)
                    if (index === 0) {
                        setTimeout(() => animatePath('home-outline-0'), 500);
                    }
                    
                    // Animate second rhomboid (rectangles)
                    if (index === 1) {
                        setTimeout(() => {
                            animatePathGroup(['left-rectangle', 'middle-rectangle', 'right-rectangle'], 500, 100, 0);
                        }, 500);
                    }
                    
                    // Animate third rhomboid
                    if (index === 2) {
                        setTimeout(() => animatePath('cube-outline'), 500);
                    }
                    
                    // Animate fourth rhomboid 
                    if (index === 3) {
                        setTimeout(() => animatePath('mail-outline'), 500);
                    }
                    
                    // After initial movement is complete, start wave animation
                    setTimeout(() => {
                        rhomboid.style.transform = ''; // Clear inline transform to allow animation
                        rhomboid.classList.add('active'); // Add animation class
                    }, 1500);
                }, index * 400); // 400ms delay between each rhomboid
            });
            
            // Mark animation as complete so we can handle scroll
            animationComplete = true;
            
            // Show scroll indicator
            document.querySelector('.scroll-indicator').style.opacity = '1';
        }
        // Add this variable to track if card animation is in progress
let cardsAnimating = false;

// Handle scroll event to transition layout
window.addEventListener('scroll', () => {
    if (!animationComplete) return;
    
    // Calculate scroll percentage (0 to 1)
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
    const scrollPercentage = Math.min(1, scrollTop / (scrollHeight / 4)); // Transition in first quarter of scroll
    
    // Apply transformation based on scroll percentage
    const animationContainer = document.getElementById('animation-container');
    const taglineContainer = document.getElementById('tagline-container');
    const contentContainer = document.querySelector('.content-container');
    const circularImage = document.querySelector('.circular-image');
    const contentBox = document.querySelector('.content-box');
    const scrollIndicator = document.querySelector('.scroll-indicator');
    const cards = document.querySelectorAll('.card');
    const cardc = document.querySelector('.cards-container');
    
    // For smooth shrinking before slide
    if (scrollPercentage <= 0.4) {
        // Only shrink during the first 40% of the scroll transition
        const scale = 1 - (scrollPercentage * 1.5); // Scale from 1 down to 0.4
        const scaleValue = Math.max(0.4, scale);
        
        // Keep in center but shrink
        animationContainer.style.transform = `translate(-50%, -50%) scale(${scaleValue})`;
        animationContainer.classList.remove('scrolled');
        
        // Gradually fade out tagline

        taglineContainer.classList.remove('scrolled');
        
        // Hide content elements
        contentContainer.classList.remove('visible');
        circularImage.classList.remove('scrolled');
        contentBox.classList.remove('scrolled');
        
        // Only remove scrolled class from cards if cards aren't currently animating
        if (!cardsAnimating && cardsVisible) {
            cardsAnimating = true;
            cardsVisible = false;
            cardc.classList.remove('visible');
            
            // Use a staggered removal with delay
            cards.forEach((card, index) => {
                setTimeout(() => {
                    card.classList.remove('scrolled');
                    
                    // Only reset the animation flag after the last card
                    if (index === cards.length - 1) {
                        setTimeout(() => {
                            cardsAnimating = false;
                        }, 200); // Buffer time after last card
                    }
                }, index * 50);
            });
        }
        
        // Show scroll indicator
        scrollIndicator.style.opacity = '1';
    } 
    // When we've shrunk enough, slide to corner and show content
    else if (scrollPercentage > 0.4) {
        // Add scrolled class to apply the corner position
        animationContainer.classList.add('scrolled');
        animationContainer.style.transform = ''; // Remove inline transform to use the CSS class
        taglineContainer.classList.add('scrolled');
        contentContainer.classList.add('visible');
        
        // Show the new content elements
        if (scrollPercentage > 0.6) {
            circularImage.classList.add('scrolled');
            contentBox.classList.add('scrolled');
            
            // Only add scrolled class to cards if cards aren't currently animating
            if (!cardsAnimating && !cardsVisible) {
                cardsAnimating = true;
                cardsVisible = true;
                cardc.classList.add('visible');
                
                // Initialize cards first if needed
                if (!activeCard) {
                    initializeCards();
                }
                
                // Use a staggered application with delay
                cards.forEach((card, index) => {
                    setTimeout(() => {
                        card.classList.add('scrolled');
                        
                        // Only reset the animation flag after the last card
                        if (index === cards.length - 1) {
                            setTimeout(() => {
                                cardsAnimating = false;
                            }, 200); // Buffer time after last card
                        }
                    }, index * 100);
                });
            }
            
            // Hide scroll indicator
            scrollIndicator.style.opacity = '0';
        }
    }
});
        // Function to handle parallax effect for touch devices
        function handleTouchParallax() {
            if ('ontouchstart' in window) {
                // For mobile devices, create gyroscope-based parallax
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        if (!parallaxEnabled) return;
                        
                        // Use device tilt for parallax on mobile
                        const tiltX = e.gamma / 45; // Normalize from -1 to 1 (gamma ranges from -90 to 90)
                        const tiltY = e.beta / 45;  // Normalize from -1 to 1 (beta ranges from -90 to 90)
                        
                        // Apply different movement speeds to each layer
                        const frontLayer = document.getElementById('bubble-layer-front');
                        const middleLayer = document.getElementById('bubble-layer-middle');
                        const backLayer = document.getElementById('bubble-layer-back');
                        
                        // Adjust movement based on device orientation
                        frontLayer.style.transform = `translate(${-tiltX * 30}px, ${-tiltY * 30}px)`;
                        middleLayer.style.transform = `translate(${-tiltX * 15}px, ${-tiltY * 15}px)`;
                        backLayer.style.transform = `translate(${-tiltX * 7}px, ${-tiltY * 7}px)`;
                    });
                }
            }
        }
        
        // Initialize
        window.addEventListener('resize', adjustSpaceWidth);
        adjustSpaceWidth();
        handleTouchParallax();
        // Add this to your JavaScript before the final closing tag
// Card animation variables
let activeCard = null;
let cardsVisible = false;

// Card slot positions on screen (in pixels, will be calculated)
let cardSlotPositions = [0, 0, 0, 0, 0];

// Function to initialize the cards
function initializeCards() {
    const cards = document.querySelectorAll('.card');
    const cardsContainer = document.querySelector('.cards-container');
    
    // Calculate slot positions based on container width
    calculateCardSlotPositions();
    
    // Assign each card to its initial slot
    cards.forEach((card, index) => {
        // Set initial slot
        card.setAttribute('data-slot', index);
        
        // Position card in its slot
        positionCardInSlot(card, index);
        
        // Add click handler
        card.addEventListener('click', () => {
            handleCardClick(card);
        });
    });
    
    // Add window resize handler to recalculate positions when screen size changes
    window.addEventListener('resize', () => {
        calculateCardSlotPositions();
        
        // Reposition all cards in their current slots
        cards.forEach(card => {
            const currentSlot = parseInt(card.getAttribute('data-slot'));
            if (card !== activeCard) {
                positionCardInSlot(card, currentSlot);
            }
        });
    });
}

// Calculate the actual pixel positions for each card slot
function calculateCardSlotPositions() {
    const cardsContainer = document.querySelector('.cards-container');
    const containerWidth = cardsContainer.offsetWidth;
    const cardWidth = 180; // Base card width
    const cardGap = 20; // Gap between cards
    
    // Calculate center position of container
    const containerCenter = containerWidth / 2;
    
    // Calculate total width of all cards + gaps
    const totalCardsWidth = (5 * cardWidth) + (4 * cardGap);
    
    // Calculate starting position (left edge of first card)
    const startX = containerCenter - (totalCardsWidth / 2);
    
    // Calculate position for each slot
    for (let i = 0; i < 5; i++) {
        cardSlotPositions[i] = startX + (i * (cardWidth + cardGap));
    }
}

// Position a card in a specific slot
function positionCardInSlot(card, slotIndex) {
    // Update card's slot attribute
    card.setAttribute('data-slot', slotIndex);
    
    // Remove any inline styles from previous positioning
    card.style.removeProperty('transform');
    card.style.removeProperty('transition');
    
    // Apply new position
    const leftPosition = cardSlotPositions[slotIndex];
    card.style.position = 'absolute';
    card.style.left = `${leftPosition}px`;
    card.style.bottom = '0';
    card.style.transform = '';
    card.style.transition = 'all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
}

// Handle card click
function handleCardClick(card) {
    // Prevent rapid clicks
    if (card.classList.contains('processing')) return;
    card.classList.add('processing');
    
    // Check if this card is already active
    if (card === activeCard) {
        deactivateCard();
        setTimeout(() => {
            card.classList.remove('processing');
        }, 1000);
        return;
    }
    
    // If there's already an active card, deactivate it first
    if (activeCard) {
        deactivateCard();
        setTimeout(() => {
            activateCard(card);
            setTimeout(() => {
                card.classList.remove('processing');
            }, 1000);
        }, 800);
    } else {
        activateCard(card);
        setTimeout(() => {
            card.classList.remove('processing');
        }, 1000);
    }
}

// Activate a card (move to content box and expand)
function activateCard(card) {
    // Store the current slot
    const currentSlot = parseInt(card.getAttribute('data-slot'));
    card.setAttribute('data-original-slot', currentSlot);
    
    // Get content box dimensions and position
    const contentBox = document.querySelector('.content-box');
    const contentBoxRect = contentBox.getBoundingClientRect();
    
    // Get card's current position
    const cardRect = card.getBoundingClientRect();
    
    // First, fix the card in its current position
    card.style.position = 'fixed';
    card.style.top = `${cardRect.top}px`;
    card.style.left = `${cardRect.left}px`;
    card.style.width = `${cardRect.width}px`;
    card.style.height = `${cardRect.height}px`;
    card.style.zIndex = '20';
    
    // Force reflow
    void card.offsetHeight;
    
    // Then animate to content box position
    card.classList.add('active');
    card.style.width = `${contentBoxRect.width}px`;
    card.style.height = `${contentBoxRect.height}px`;
    card.style.top = `${contentBoxRect.top}px`;
    card.style.left = `${contentBoxRect.left}px`;
    
    // Flip card after it reaches destination
    setTimeout(() => {
        card.querySelector('.card-inner').style.transform = 'rotateY(180deg)';
    }, 500);
    
    // Set as active card
    activeCard = card;
    
    // Move other cards to fill the gap
    shiftCardsAfterActivation(currentSlot);
}

// Shift cards after a card has been activated
function shiftCardsAfterActivation(activatedSlot) {
    const cards = document.querySelectorAll('.card');
    
    // The activated card is now conceptually in slot 4 (rightmost)
    // Move all other cards to slots 0-3
    
    cards.forEach(card => {
        if (card !== activeCard) {
            const currentSlot = parseInt(card.getAttribute('data-slot'));
            
            // If the card is to the right of the activated card, move it left
            if (currentSlot > activatedSlot) {
                positionCardInSlot(card, currentSlot - 1);
            }
        }
    });
}

// Deactivate the currently active card
function deactivateCard() {
    if (!activeCard) return;
    
    // First, reset the flip animation
    activeCard.querySelector('.card-inner').style.transform = '';
    const originalCard = activeCard;
    
   
        // Move the card to slot 4 (rightmost)
        moveCardToRightmost(originalCard);
        
        // Clear active card reference
        activeCard = null;
        
        // Remove active class and reset styles after movement
        
            originalCard.classList.remove('active');
            originalCard.style.position = 'absolute';
            originalCard.style.zIndex = '1';
            originalCard.style.top = '';
            originalCard.style.bottom = '0';
            originalCard.style.width = '180px'; // Reset to original width
            originalCard.style.height = '240px'; // Reset to original height
            
            // Also apply responsive sizing if needed
            if (window.innerWidth <= 992 && window.innerWidth > 600) {
                originalCard.style.width = '150px';
                originalCard.style.height = '200px';
            } else if (window.innerWidth <= 600) {
                originalCard.style.width = '120px';
                originalCard.style.height = '170px';
            }
}

// Move a card to the rightmost position (slot 4)
function moveCardToRightmost(card) {
    const cards = document.querySelectorAll('.card');
    
    // First, find any card that's in slot 4
    let cardInLastSlot = null;
    cards.forEach(c => {
        if (parseInt(c.getAttribute('data-slot')) === 4 && c !== card) {
            cardInLastSlot = c;
        }
    });
    
    // Move all cards one slot to the left to make room
    // but only if our card isn't already in the last slot
    if (parseInt(card.getAttribute('data-slot')) !== 4) {
        // Shift all cards in slots 3 and below left by one
        cards.forEach(c => {
            if (c !== card) {
                const currentSlot = parseInt(c.getAttribute('data-slot'));
                if (currentSlot < 4) {
                    // Move left
                    positionCardInSlot(c, currentSlot);
                }
            }
        });
        
        // If there was a card in slot 4, move it to slot 3
        if (cardInLastSlot) {
            positionCardInSlot(cardInLastSlot, 3);
        }
        
        // Position our card in slot 4
        card.style.transition = 'all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
        positionCardInSlot(card, 4);
    }
}
// Party Mode Variables
let partyModeActive = false;
let originalCardContent = [];

// Initialize party mode elements
function initPartyMode() {
    // Add click event to the circular image
    const circularImage = document.querySelector('.circular-image');
    circularImage.addEventListener('click', activatePartyMode);
    
    // Add click event to the close button
    const closeButton = document.querySelector('.rhomboid-close');
    closeButton.addEventListener('click', deactivatePartyMode);
    
    // Animate SVG cross paths
    animatePath('cross-1', 800, 0);
    animatePath('cross-2', 800, 400);
    
    // Store original card content
    const cards = document.querySelectorAll('.card');
    cards.forEach((card, index) => {
        const cardInner = card.querySelector('.card-inner');
        const cardBack = card.querySelector('.card-back');
        
        // Store the original content
        originalCardContent[index] = {
            title: cardBack.querySelector('h3').textContent,
            content: cardBack.querySelector('p').textContent
        };
    });
}
function updateCardWithPartyContent(card, index) {
    const cardBack = card.querySelector('.card-back');
    const titleElement = cardBack.querySelector('h3');
    const contentElement = cardBack.querySelector('p');
    
    // Party mode content with images and titles
    const partyContent = [
        { title: "Medicine", image: "party/track/medicine.jpg" },
        { title: "Dance Floor", image: "party2.jpg" },
        { title: "Party Vibes", image: "party3.jpg" },
        { title: "Music Scene", image: "party4.jpg" },
        { title: "Festival Mode", image: "party5.jpg" }
    ];
    
    // Get party content for this card
    const content = partyContent[index];
    
    // Store original content if not already stored
    if (!originalCardContent[index]) {
        originalCardContent[index] = {
            content: contentElement.innerHTML,
            title: titleElement.textContent
            
        };
    }
    
    // Update title
    titleElement.textContent = content.title;
    
    // Replace paragraph with image
    contentElement.innerHTML = `<img src="${content.image}" alt="${content.title}" style="max-width: 90%; max-height: 70%; border-radius: 8px; margin-top: 10px;">`;
}
function restoreOriginalCardContent(card, index) {
    if (!originalCardContent[index]) return;
    
    const cardBack = card.querySelector('.card-back');
    const titleElement = cardBack.querySelector('h3');
    const contentElement = cardBack.querySelector('p');
    
    // Restore original content
    titleElement.textContent = originalCardContent[index].title;
    contentElement.innerHTML = originalCardContent[index].content;
}

// Add call to restoreOriginalCardContent in resetCardsFromPartyMode
function resetCardsFromPartyMode() {
    const cards = document.querySelectorAll('.card');
    const cardsContainer = document.querySelector('.cards-container');
    
    // Remove party mode from container
    cardsContainer.classList.remove('party-mode');
    
    // For each card, revert styles
    cards.forEach((card, index) => {
        // First flip card back
        card.querySelector('.card-inner').style.transform = '';
        
        // Remove party mode class and reset styles with a delay
        setTimeout(() => {
            card.classList.remove('party-mode');
            card.style.position = 'absolute';
            card.style.top = '';
            card.style.left = '';
            card.style.bottom = '0';
            
            // Reset position in original slot
            positionCardInSlot(card, index);
            
            // Restore original content
            restoreOriginalCardContent(card, index);
            
        }, (cards.length - index) * 100); // Reverse order for removal
    });
}
// Activate party mode
function activatePartyMode() {
    if (partyModeActive) return;
    partyModeActive = true;
    
    // Add class to body to lock scrolling
    document.body.classList.add('party-mode');
    
    // Transform the circular image
    const circularImage = document.querySelector('.circular-image');
    circularImage.classList.add('party-mode');
    
    // Hide the content box - make sure it moves off screen
    const contentBox = document.querySelector('.content-box');
    contentBox.classList.add('party-mode');
    
    // Hide rhomboid menu - make sure all rhomboids move off screen
    const rhomboids = document.querySelectorAll('#rhomboids-container .rhomboid');
    rhomboids.forEach(rhomboid => {
        // Force transform to ensure they move
        rhomboid.style.transform = 'translateX(400px)'; 
        rhomboid.classList.add('party-mode-hide');
    });
    
    // Show close button
    setTimeout(() => {
        const closeButton = document.querySelector('.rhomboid-close');
        closeButton.classList.add('active');
    }, 800);
    
    // Transform cards
    transformCardsForPartyMode();
}


// Deactivate party mode
function deactivatePartyMode() {
    if (!partyModeActive) return;
    
    // Hide close button first
    const closeButton = document.querySelector('.rhomboid-close');
    closeButton.classList.remove('active');
    
    // Wait for close button to animate out
    setTimeout(() => {
        partyModeActive = false;
        
        // Remove class from body to unlock scrolling
        document.body.classList.remove('party-mode');
        
        // Return the circular image to normal
        const circularImage = document.querySelector('.circular-image');
        circularImage.classList.remove('party-mode');
        
        // Show the content box
        const contentBox = document.querySelector('.content-box');
        contentBox.classList.remove('party-mode');
        
        // Show rhomboid menu
        const rhomboids = document.querySelectorAll('#rhomboids-container .rhomboid');
        rhomboids.forEach(rhomboid => {
            rhomboid.style.transform = ''; // Clear inline transform
            rhomboid.classList.remove('party-mode-hide');
            // Re-add active class to make animations work again
            setTimeout(() => {
                rhomboid.classList.add('active');
            }, 500);
        });
        
        // Return cards to normal
        resetCardsFromPartyMode();
    }, 500);
}

// Transform cards for party mode
function transformCardsForPartyMode() {
    const cards = document.querySelectorAll('.card');
    const cardsContainer = document.querySelector('.cards-container');
    
    // Change container style
    cardsContainer.classList.add('party-mode');
    
    // For each card, apply party mode
    cards.forEach((card, index) => {
        // Update card content first (while still hidden)
        updateCardWithPartyContent(card, index);
        
        // Make sure card is visible first
        card.classList.add('scrolled');
        
        // Delay the transformation to create a sequential effect
        setTimeout(() => {
            // Add party mode class without adding active class
            card.classList.add('party-mode');
            
            // Only flip the inner card without activating the card itself
            card.querySelector('.card-inner').style.transform = 'rotateY(180deg)';
        }, index * 150);
    });
}

// Reset cards from party mode
function resetCardsFromPartyMode() {
    const cards = document.querySelectorAll('.card');
    const cardsContainer = document.querySelector('.cards-container');
    
    // Remove party mode from container
    cardsContainer.classList.remove('party-mode');
    
    // For each card, revert styles
    cards.forEach((card, index) => {
        // First flip card back
        card.querySelector('.card-inner').style.transform = '';
        
        // Remove party mode class with a delay
        setTimeout(() => {
            card.classList.remove('party-mode');
            
            // Restore original content
            restoreOriginalCardContent(card, index);
        }, (cards.length - index) * 100); // Reverse order for removal
    });
}
// Rhythm Game Implementation
// To be added to your existing website

// Define the RhythmGame class
class RhythmGame {
    constructor() {
        // Game state
        this.isActive = false;
        this.currentTrack = null;
        this.noteMap = null;
        this.score = 0;
        this.combo = 0;
        this.maxCombo = 0;
        this.hits = { perfect: 0, great: 0, good: 0, miss: 0, total: 0 };
        this.activeNotes = [];
        this.audio = null;
        this.pressedKeys = { 'd': false, 'f': false, 'j': false, 'k': false };
        
        // Game settings
        this.noteSpeed = 60; // vh per second - how fast notes travel
        this.hitZonePosition = 15; // vh from top
        this.hitWindowTiming = {
            perfect: 50,   // ms
            great: 120,    // ms
            good: 200,     // ms
            miss: 300      // ms
        };
        
        // Calculated values
        this.spawnToHitTime = 0; // Will be calculated based on speed
        
        // UI elements - will be created dynamically
        this.gameContainer = null;
        this.keyIndicators = {};
        this.noteAreas = {};
        this.countdownElement = null;
        this.scoreDisplay = null;
        this.comboDisplay = null;
        
        // Audio context for precise timing
        this.audioContext = null;
        this.startTime = 0;
        
        // Bind methods
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleKeyUp = this.handleKeyUp.bind(this);
        this.update = this.update.bind(this);
        
        // Animation frame
        this.animationFrame = null;
    }
    
    // Initialize the game
    init() {
        // Create game container
        this.createGameContainer();
        
        // Calculate spawn timing based on note speed
        this.spawnToHitTime = (this.hitZonePosition / this.noteSpeed) * 1000; // in ms
        
        // Set up event listeners for keys
        document.addEventListener('keydown', this.handleKeyDown);
        document.addEventListener('keyup', this.handleKeyUp);
        
        console.log("Rhythm Game initialized");
    }
    
    // Create the game container and UI elements
    createGameContainer() {
        // Create main container
        this.gameContainer = document.createElement('div');
        this.gameContainer.className = 'rhythm-game-container';
        this.gameContainer.style.display = 'none';
        
        // Create styles
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            .rhythm-game-container {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100vh;
                background-color: rgba(0, 0, 0, 0.85);
                z-index: 1000;
                overflow: hidden;
            }
            
            .rhythm-lane {
                position: absolute;
                width: 20%;
                height: 100%;
                border-right: 1px solid rgba(255, 255, 255, 0.2);
                box-sizing: border-box;
            }
            
            .key-indicator {
                position: absolute;
                width: 60px;
                height: 60px;
                background-color: rgba(255, 255, 255, 0.15);
                border-radius: 8px;
                color: white;
                font-size: 24px;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                top: ${this.hitZonePosition}vh;
                transform: translateY(-100%);
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
                transition: background-color 0.1s ease;
            }
            
            .key-indicator.active {
                background-color: rgba(255, 255, 255, 0.4);
                box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
            }
            
            .key-indicator-d { left: 15%; }
            .key-indicator-f { left: 35%; }
            .key-indicator-j { left: 55%; }
            .key-indicator-k { left: 75%; }
            
            .note-area {
                position: absolute;
                width: 20%;
                height: 100%;
                overflow: hidden;
            }
            
            .note-area-d { left: 5%; }
            .note-area-f { left: 25%; }
            .note-area-j { left: 45%; }
            .note-area-k { left: 65%; }
            
            .game-note {
                position: absolute;
                width: 50px;
                height: 50px;
                left: 50%;
                transform: translateX(-50%);
                border-radius: 8px;
                opacity: 0.8;
            }
            
            .game-note-d { background-color: rgba(255, 50, 50, 0.8); }
            .game-note-f { background-color: rgba(50, 255, 50, 0.8); }
            .game-note-j { background-color: rgba(50, 50, 255, 0.8); }
            .game-note-k { background-color: rgba(255, 255, 50, 0.8); }
            
            .hold-note {
                border-radius: 8px 8px 0 0;
            }
            
            .hold-body {
                position: absolute;
                width: 50px;
                left: 50%;
                transform: translateX(-50%);
                opacity: 0.6;
                border-radius: 0 0 8px 8px;
            }
            
            .countdown {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 80px;
                color: white;
                font-weight: bold;
                text-align: center;
                z-index: 100;
                opacity: 0;
                transition: all 0.5s ease;
            }
            
            .rhythm-scoreboard {
                position: absolute;
                top: 20px;
                right: 20px;
                background-color: rgba(0, 0, 0, 0.7);
                padding: 15px;
                border-radius: 10px;
                z-index: 10;
                display: flex;
                flex-direction: column;
                gap: 5px;
            }
            
            .score-display {
                color: white;
                font-size: 24px;
                font-weight: bold;
            }
            
            .combo-display {
                color: #ff9900;
                font-size: 18px;
            }
            
            .judgment-text {
                position: absolute;
                font-weight: bold;
                font-size: 24px;
                color: white;
                text-align: center;
                pointer-events: none;
                opacity: 0;
                z-index: 100;
                animation: judgmentAnim 1s ease-out forwards;
            }
            
            @keyframes judgmentAnim {
                0% { opacity: 0; transform: translateY(0); }
                20% { opacity: 1; }
                100% { opacity: 0; transform: translateY(-30px); }
            }
            
            .judgment-perfect { color: #ffeb3b; }
            .judgment-great { color: #4caf50; }
            .judgment-good { color: #2196f3; }
            .judgment-miss { color: #f44336; }
            
            .return-button {
                position: absolute;
                top: 20px;
                left: 20px;
                padding: 10px 20px;
                background-color: rgba(255, 255, 255, 0.2);
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                z-index: 10;
                font-weight: bold;
                transition: background-color 0.3s ease;
            }
            
            .return-button:hover {
                background-color: rgba(255, 255, 255, 0.3);
            }
        `;
        document.head.appendChild(styleElement);
        
        // Create the four lanes
        ['d', 'f', 'j', 'k'].forEach(key => {
            // Create lane
            const lane = document.createElement('div');
            lane.className = `rhythm-lane rhythm-lane-${key}`;
            lane.style.left = this.getLanePosition(key);
            this.gameContainer.appendChild(lane);
            
            // Create key indicator
            const keyIndicator = document.createElement('div');
            keyIndicator.className = `key-indicator key-indicator-${key}`;
            keyIndicator.textContent = key.toUpperCase();
            keyIndicator.style.left = this.getKeyPosition(key);
            this.gameContainer.appendChild(keyIndicator);
            this.keyIndicators[key] = keyIndicator;
            
            // Create note area
            const noteArea = document.createElement('div');
            noteArea.className = `note-area note-area-${key}`;
            this.gameContainer.appendChild(noteArea);
            this.noteAreas[key] = noteArea;
        });
        
        // Create countdown element
        this.countdownElement = document.createElement('div');
        this.countdownElement.className = 'countdown';
        this.gameContainer.appendChild(this.countdownElement);
        
        // Create score display
        const scoreboard = document.createElement('div');
        scoreboard.className = 'rhythm-scoreboard';
        
        this.scoreDisplay = document.createElement('div');
        this.scoreDisplay.className = 'score-display';
        this.scoreDisplay.textContent = 'Score: 0';
        scoreboard.appendChild(this.scoreDisplay);
        
        this.comboDisplay = document.createElement('div');
        this.comboDisplay.className = 'combo-display';
        this.comboDisplay.textContent = 'Combo: 0';
        scoreboard.appendChild(this.comboDisplay);
        
        this.gameContainer.appendChild(scoreboard);
        
        // Create return button
        const returnButton = document.createElement('button');
        returnButton.className = 'return-button';
        returnButton.textContent = 'Exit Game';
        returnButton.addEventListener('click', () => this.endGame());
        this.gameContainer.appendChild(returnButton);
        
        // Add to document
        document.body.appendChild(this.gameContainer);
    }
    
    // Get position for lane
    getLanePosition(key) {
        const positions = {
            'd': '5%',
            'f': '25%',
            'j': '45%',
            'k': '65%'
        };
        return positions[key] || '0';
    }
    
    // Get position for key indicator
    getKeyPosition(key) {
        const positions = {
            'd': '15%',
            'f': '35%',
            'j': '55%',
            'k': '75%'
        };
        return positions[key] || '0';
    }
    
    // Start the game with a specific track
    startGame(trackId, noteMapData) {
        if (this.isActive) return;
        
        this.isActive = true;
        this.currentTrack = trackId;
        
        // Parse the note map data
        try {
            this.noteMap = noteMapData.notes || [];
            console.log(`Loaded note map with ${this.noteMap.length} notes`);
        } catch (error) {
            console.error("Error parsing note map:", error);
            this.noteMap = [];
        }
        
        // Reset game state
        this.resetGameState();
        
        // Show game container
        this.gameContainer.style.display = 'block';
        
        // Start countdown
        this.startCountdown();
    }
    
    // Reset game state
    resetGameState() {
        this.score = 0;
        this.combo = 0;
        this.maxCombo = 0;
        this.hits = { perfect: 0, great: 0, good: 0, miss: 0, total: 0 };
        this.activeNotes = [];
        
        // Reset UI
        this.updateScoreDisplay();
        
        // Clear note areas
        Object.values(this.noteAreas).forEach(area => {
            area.innerHTML = '';
        });
        
        // Clear key indicators
        Object.keys(this.keyIndicators).forEach(key => {
            this.keyIndicators[key].classList.remove('active');
        });
        
        // Reset note flags
        this.noteMap.forEach(note => {
            note.spawned = false;
            note.hit = false;
            note.missed = false;
            note.element = null;
        });
    }
    
    // Start the countdown sequence
    startCountdown() {
        const countdownValues = [3, 2, 1, 'GO!'];
        let index = 0;
        
        const showNumber = () => {
            if (index >= countdownValues.length) {
                // Countdown finished, start the audio
                this.startAudio();
                return;
            }
            
            this.countdownElement.textContent = countdownValues[index];
            this.countdownElement.style.opacity = 1;
            this.countdownElement.style.transform = 'translate(-50%, -50%) scale(1.5)';
            
            setTimeout(() => {
                this.countdownElement.style.opacity = 0;
                this.countdownElement.style.transform = 'translate(-50%, -50%) scale(1)';
                
                setTimeout(() => {
                    index++;
                    showNumber();
                }, 200);
            }, 800);
        };
        
        showNumber();
    }
    
    // Start the audio playback
    startAudio() {
        try {
            // Create audio element
            this.audio = new Audio(`${this.currentTrack}`);
            
            // Set up event listeners
            this.audio.addEventListener('ended', () => this.endGame());
            
            // Set up audio context for precise timing
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.startTime = this.audioContext.currentTime;
            
            // Start playback
            this.audio.play().then(() => {
                console.log("Audio playback started");
                this.update(); // Start the game loop
            }).catch(error => {
                console.error("Error playing audio:", error);
            });
        } catch (error) {
            console.error("Error starting audio:", error);
        }
    }
    
    // End the game
    endGame() {
        if (!this.isActive) return;
        
        // Stop audio
        if (this.audio) {
            this.audio.pause();
            this.audio = null;
        }
        
        // Stop animation
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
        }
        
        // Hide game container
        this.gameContainer.style.display = 'none';
        
        // Reset active state
        this.isActive = false;
        
        // Show results
        this.showResults();
        
        // Call any cleanup or deactivation method from the parent page
        if (typeof deactivatePartyMode === 'function') {
            deactivatePartyMode();
        }
    }
    
    // Show game results
    showResults() {
        // Calculate accuracy
        let accuracy = 0;
        if (this.hits.total > 0) {
            accuracy = ((this.hits.perfect * 100) + (this.hits.great * 80) + (this.hits.good * 50)) / (this.hits.total * 100) * 100;
        }
        
        // Alert or more sophisticated UI could be used here
        alert(`Game Over!\n\nScore: ${this.score}\nMax Combo: ${this.maxCombo}\nAccuracy: ${accuracy.toFixed(1)}%\n\nPerfect: ${this.hits.perfect}\nGreat: ${this.hits.great}\nGood: ${this.hits.good}\nMiss: ${this.hits.miss}`);
    }
    
    // Main game loop
    update() {
        if (!this.isActive || !this.audio) return;
        
        // Calculate current time
        const currentTime = (this.audioContext.currentTime - this.startTime) * 1000; // in ms
        
        // Update note positions
        this.updateNotes(currentTime);
        
        // Request next frame
        this.animationFrame = requestAnimationFrame(this.update);
    }
    
    // Update notes based on current time
    updateNotes(currentTime) {
        // Spawn window - how early notes appear before hit point
        const spawnWindow = this.spawnToHitTime;
        
        // Find notes that should be spawned
        const notesToSpawn = this.noteMap.filter(note => 
            !note.spawned && 
            note.time <= currentTime + spawnWindow
        );
        
        // Spawn new notes
        notesToSpawn.forEach(note => {
            this.spawnNote(note, currentTime);
            note.spawned = true;
            this.activeNotes.push(note);
        });
        
        // Update positions of active notes
        this.activeNotes.forEach(note => {
            this.updateNotePosition(note, currentTime);
            
            // Check if note is missed
            if (!note.hit && !note.missed && note.time < currentTime - this.hitWindowTiming.miss) {
                this.missNote(note);
            }
        });
        
        // Remove notes that are far past the hit window
        this.activeNotes = this.activeNotes.filter(note => {
            if (note.hit || note.missed) {
                // Remove from DOM and active notes list
                if (note.element && note.element.parentNode) {
                    note.element.remove();
                }
                if (note.holdElement && note.holdElement.parentNode) {
                    note.holdElement.remove();
                }
                return false;
            }
            return true;
        });
    }
    
    // Spawn a note element
    spawnNote(note, currentTime) {
        const noteArea = this.noteAreas[note.lane];
        if (!noteArea) return;
        
        // Create note element
        const noteElement = document.createElement('div');
        noteElement.className = `game-note game-note-${note.lane}`;
        
        // Calculate initial position (at bottom of screen)
        noteElement.style.bottom = '0';
        
        // For hold notes
        if (note.type === 'hold' && note.duration) {
            noteElement.classList.add('hold-note');
            
            // Create the hold body
            const holdElement = document.createElement('div');
            holdElement.className = `hold-body game-note-${note.lane}`;
            
            // Calculate height based on duration
            const holdHeight = (note.duration / 1000) * this.noteSpeed; // vh units
            holdElement.style.height = `${holdHeight}vh`;
            
            // Initial position - attached to the bottom of the note head
            holdElement.style.bottom = '0';
            
            // Add to DOM
            noteArea.appendChild(holdElement);
            
            // Store reference
            note.holdElement = holdElement;
        }
        
        // Add to DOM
        noteArea.appendChild(noteElement);
        
        // Store reference
        note.element = noteElement;
    }
    
    // Update position of a note
    updateNotePosition(note, currentTime) {
        if (!note.element) return;
        
        // Calculate time difference to hit point
        const timeDiff = note.time - currentTime;
        
        // Calculate position based on time
        const position = (this.hitZonePosition - (timeDiff / 1000 * this.noteSpeed));
        
        // Update position
        note.element.style.bottom = `${100 - position}vh`;
        
        // For hold notes, update body position
        if (note.type === 'hold' && note.holdElement) {
            note.holdElement.style.bottom = `${100 - position - 5}vh`; // 5vh is height of note head
        }
    }
    
    // Handle key down event
    handleKeyDown(event) {
        if (!this.isActive) return;
        
        const key = event.key.toLowerCase();
        
        // Only handle D, F, J, K keys
        if (!['d', 'f', 'j', 'k'].includes(key)) return;
        
        // Prevent default behavior (scrolling, etc.)
        event.preventDefault();
        
        // Check if key is already pressed
        if (this.pressedKeys[key]) return;
        
        // Mark key as pressed
        this.pressedKeys[key] = true;
        
        // Visual feedback
        const keyIndicator = this.keyIndicators[key];
        if (keyIndicator) {
            keyIndicator.classList.add('active');
        }
        
        // Check if key hit any notes
        this.checkNoteHit(key);
    }
    
    // Handle key up event
    handleKeyUp(event) {
        if (!this.isActive) return;
        
        const key = event.key.toLowerCase();
        
        // Only handle D, F, J, K keys
        if (!['d', 'f', 'j', 'k'].includes(key)) return;
        
        // Prevent default behavior
        event.preventDefault();
        
        // Mark key as released
        this.pressedKeys[key] = false;
        
        // Visual feedback
        const keyIndicator = this.keyIndicators[key];
        if (keyIndicator) {
            keyIndicator.classList.remove('active');
        }
    }
    
    // Check if key press hit a note
    checkNoteHit(key) {
        if (!this.isActive || !this.audioContext) return;
        
        // Current time in ms
        const currentTime = (this.audioContext.currentTime - this.startTime) * 1000;
        
        // Find notes in this lane that are within hit window
        const notesInLane = this.activeNotes.filter(note => 
            note.lane === key && !note.hit && !note.missed
        );
        
        if (notesInLane.length === 0) return;
        
        // Sort by time difference to find closest note
        notesInLane.sort((a, b) => 
            Math.abs(a.time - currentTime) - Math.abs(b.time - currentTime)
        );
        
        // Get closest note
        const closestNote = notesInLane[0];
        const timeDiff = Math.abs(closestNote.time - currentTime);
        
        // Check if within hit window
        if (timeDiff <= this.hitWindowTiming.miss) {
            this.hitNote(closestNote, timeDiff);
        }
    }
    
    // Handle note hit
    hitNote(note, accuracy) {
        if (note.hit || note.missed) return;
        
        // Mark as hit
        note.hit = true;
        
        // Determine judgment based on accuracy
        let judgment = '';
        let points = 0;
        
        if (accuracy <= this.hitWindowTiming.perfect) {
            judgment = 'PERFECT';
            points = 1000;
            this.hits.perfect++;
        } else if (accuracy <= this.hitWindowTiming.great) {
            judgment = 'GREAT';
            points = 800;
            this.hits.great++;
        } else if (accuracy <= this.hitWindowTiming.good) {
            judgment = 'GOOD';
            points = 500;
            this.hits.good++;
        } else {
            judgment = 'MISS';
            points = 0;
            this.hits.miss++;
            this.combo = 0; // Reset combo on miss
        }
        
        // If not a miss, increase combo
        if (judgment !== 'MISS') {
            this.combo++;
            this.maxCombo = Math.max(this.maxCombo, this.combo);
        }
        
        // Add score
        this.score += points;
        this.hits.total++;
        
        // Update display
        this.updateScoreDisplay();
        
        // Visual feedback
        this.showJudgment(note.lane, judgment);
        
        // Remove note element
        if (note.element) {
            note.element.remove();
        }
        
        // For hold notes, handle the hold body
        if (note.type === 'hold' && note.holdElement) {
            note.holdElement.remove();
        }
    }
    
    // Handle missed note
    missNote(note) {
        if (note.hit || note.missed) return;
        
        // Mark as missed
        note.missed = true;
        
        // Reset combo
        this.combo = 0;
        this.hits.miss++;
        this.hits.total++;
        
        // Update display
        this.updateScoreDisplay();
        
        // Visual feedback
        this.showJudgment(note.lane, 'MISS');
    }
    
    // Show judgment text
    showJudgment(lane, judgment) {
        // Get position for the judgment text
        const position = this.getKeyPosition(lane);
        
        // Create element
        const judgmentElement = document.createElement('div');
        judgmentElement.className = `judgment-text judgment-${judgment.toLowerCase()}`;
        judgmentElement.textContent = judgment;
        judgmentElement.style.left = position;
        judgmentElement.style.top = `${this.hitZonePosition}vh`;
        
        // Add to DOM
        this.gameContainer.appendChild(judgmentElement);
        
        // Remove after animation
        setTimeout(() => {
            if (judgmentElement.parentNode) {
                judgmentElement.remove();
            }
        }, 1000);
    }
    
    // Update score display
    updateScoreDisplay() {
        this.scoreDisplay.textContent = `Score: ${this.score}`;
        this.comboDisplay.textContent = `Combo: ${this.combo}`;
    }
}

// Implementation for integrating with existing page

// Global rhythm game instance
let rhythmGame = null;

// Initialize the game when document is ready
document.addEventListener('DOMContentLoaded', function() {
    rhythmGame = new RhythmGame();
    rhythmGame.init();
    
    // Set up card click handlers for party mode - attach to the transform function
    setupPartyModeIntegration();
});

// Set up integration with existing party mode
function setupPartyModeIntegration() {
    // Wait for the page to load all elements
    setTimeout(() => {
        // Load the Medicine.json file for use
        loadNoteMapData();
        
        // Extend the transformCardsForPartyMode function to include rhythm game setup
        const originalTransformCards = window.transformCardsForPartyMode;
        
        window.transformCardsForPartyMode = function() {
            // Call the original function first
            if (typeof originalTransformCards === 'function') {
                originalTransformCards();
            }
            
            // Now set up the rhythm game click handlers
            setupRhythmGameCardHandlers();
        };
        
        // Notify that integration is complete
        console.log("Rhythm Game integrated with Party Mode");
    }, 2000);
}

// Global variable to store the note map data
let medicineNoteMap = null;

// Load the note map data from the included JSON
function loadNoteMapData() {
    try {
        // Use our medicine.json data
        medicineNoteMap = {
            "songId": "medicine.mp3",
            "notes": [] // This will be populated with the actual notes
        };
        
        // Populate the notes array based on the embedded JSON in the document
        const notesFromJson = []; // We'll populate this from the document content

        // The full medicine.json was included in your HTML. Let's parse it manually.
        // This is a simplified approach for demonstration - in production, you'd use fetch or import
        
        // For the purpose of this implementation, we'll use pre-loaded data
        // In production, use a proper fetch or file load mechanism
        
        // Mock data structure - to be replaced with real data
        const notesJSONData = getMedicineNoteData();
        
        if (notesJSONData && notesJSONData.length > 0) {
            medicineNoteMap.notes = notesJSONData;
            console.log(`Loaded ${medicineNoteMap.notes.length} notes for Medicine track`);
        } else {
            console.error("Failed to parse medicine.json notes data");
        }
    } catch (error) {
        console.error("Error loading note map data:", error);
    }
}

// Get the medicine note data from parsed JSON
function getMedicineNoteData() {
    // Simulated data retrieval - this should come from your medicine.json
    // In a real implementation, parse the JSON file correctly
    
    // This is a placeholder - your HTML contains the full JSON which should be properly parsed
    // For demo purposes, returning a minimal set of notes
    return [
        { "time": 1867, "lane": "f" },
        { "time": 2016, "lane": "j" },
        { "time": 2159, "lane": "k" },
        { "time": 2339, "lane": "d" },
        { "time": 2505, "lane": "j" },
        { "time": 3068, "lane": "f" },
        { "time": 3212, "lane": "k" },
        { "time": 3384, "lane": "d" },
        { "time": 3575, "lane": "j" },
        { "time": 3761, "lane": "f" },
        // Add more notes as needed for testing
    ];
}

// Set up card handlers for rhythm game activation
function setupRhythmGameCardHandlers() {
    const cards = document.querySelectorAll('.card');
    
    cards.forEach((card, index) => {
        // Add click handler if it doesn't already have one
        if (!card.hasRhythmGameHandler) {
            card.addEventListener('click', function(event) {
                // Prevent default party mode behavior if needed
                event.stopPropagation();
                
                // Extract track info from card
                const cardId = card.getAttribute('data-card-id');
                const trackName = card.querySelector('.card-back h3').textContent;
                
                // Select the appropriate track and note map
                let trackFile = 'medicine.mp3'; // Default track
                let noteMapData = medicineNoteMap || { notes: [] };
                
                // Use different tracks based on card ID (if you have multiple tracks)
                switch(cardId) {
                    case '1':
                        trackFile = 'medicine.mp3';
                        noteMapData = medicineNoteMap;
                        break;
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                        // For demo purposes, all cards use the same track
                        // In production, each card would have its own track and note map
                        trackFile = 'medicine.mp3';
                        noteMapData = medicineNoteMap;
                        break;
                }
                
                console.log(`Starting rhythm game with track: ${trackName} (${trackFile})`);
                
                // Hide the cards and circular image to make room for the game
                document.querySelector('.cards-container').style.display = 'none';
                document.querySelector('.circular-image').style.opacity = '0';
                
                // Start the rhythm game
                if (rhythmGame) {
                    setTimeout(() => {
                        rhythmGame.startGame(trackFile, noteMapData);
                    }, 500);
                }
            });
            
            // Mark card as having handler
            card.hasRhythmGameHandler = true;
        }
    });
}

// Function to get audio preview on hover
function setupCardHoverPreview() {
    const cards = document.querySelectorAll('.card');
    let previewAudio = null;
    
    cards.forEach((card) => {
        card.addEventListener('mouseenter', function() {
            // Only preview if not in active party mode
            if (partyModeActive) return;
            
            // Stop any existing preview
            if (previewAudio) {
                previewAudio.pause();
                previewAudio = null;
            }
            
            // Create new audio element for preview
            previewAudio = new Audio('medicine.mp3');
            
            // Set volume and time position for preview
            previewAudio.volume = 0.5;
            previewAudio.currentTime = 10; // Start 10 seconds in for a highlight section
            
            // Fade in
            previewAudio.volume = 0;
            let fadeIn = setInterval(() => {
                if (previewAudio.volume < 0.5) {
                    previewAudio.volume += 0.05;
                } else {
                    clearInterval(fadeIn);
                }
            }, 50);
            
            // Play preview
            previewAudio.play();
        });
        
        card.addEventListener('mouseleave', function() {
            // Stop preview on mouse leave
            if (previewAudio) {
                // Fade out
                let fadeOut = setInterval(() => {
                    if (previewAudio.volume > 0.05) {
                        previewAudio.volume -= 0.05;
                    } else {
                        clearInterval(fadeOut);
                        previewAudio.pause();
                        previewAudio = null;
                    }
                }, 50);
            }
        });
    });
}

// Modify the deactivatePartyMode function to handle rhythm game cleanup
const originalDeactivatePartyMode = window.deactivatePartyMode;

window.deactivatePartyMode = function() {
    // End rhythm game if active
    if (rhythmGame && rhythmGame.isActive) {
        rhythmGame.endGame();
    }
    
    // Show the cards container again
    if (document.querySelector('.cards-container')) {
        document.querySelector('.cards-container').style.display = '';
    }
    
    // Show the circular image again
    if (document.querySelector('.circular-image')) {
        document.querySelector('.circular-image').style.opacity = '1';
    }
    
    // Call the original function
    if (typeof originalDeactivatePartyMode === 'function') {
        originalDeactivatePartyMode();
    }
};

// Additional helper function to extract notes from the medicine.json
function extractMedicineNotes() {
    // This function attempts to extract the note data from your HTML document
    // It's a fallback in case the initial loading method fails
    try {
        // Try to find the medicine.json content in the document
        const docContent = document.documentElement.innerHTML;
        const jsonMatch = docContent.match(/medicine\.json[\s\S]*?(\{[\s\S]*?\}\})\s*<\/document_content>/);
        
        if (jsonMatch && jsonMatch[1]) {
            const jsonString = jsonMatch[1];
            const noteData = JSON.parse(jsonString);
            return noteData.notes || [];
        }
    } catch (error) {
        console.error("Error extracting medicine notes:", error);
    }
    
    // Return a minimal set of notes as fallback
    return [
        { "time": 1867, "lane": "f" },
        { "time": 2016, "lane": "j" },
        { "time": 2159, "lane": "k" },
        { "time": 2339, "lane": "d" },
        { "time": 2505, "lane": "j" }
    ];
}

// Run setup functions when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the rhythm game
    rhythmGame = new RhythmGame();
    rhythmGame.init();
    
    // Set up card hover preview
    setupCardHoverPreview();
    
    // Set up integration with party mode
    setupPartyModeIntegration();
});

// Call this function after page load
document.addEventListener('DOMContentLoaded', function() {
    // Initialize party mode after other scripts have loaded
    setTimeout(initPartyMode, 2000);
});
        setTimeout(animateLetters, 1000);
        
    </script>
</body>
</html>